# 取り組んだ課題一覧
- 達人に学ぶDB設計

# わかったこと
- サマリーデータ(集計データ)をを冗長に保持すると正規形に違反するが、検索を高速化できる
- 選択条件を冗長に保持すると正規形に違反するが、検索を高速化できる
- 正規化は可能な限り高次にすることが大原則である、トレードオフの関係性を理解して冗長に保持するかを決定する
- 更新時のパフォーマンス:新たな列に対しての更新処理が必要になる = 更新の負荷がかかる
- データのリアルタイム性:新たな列に対して、どのようなタイミングで反映するべきなのか？どの程度最新性が求めらるのかを、業務要件とセットで考えるべき。反映周期が短い→システム負荷高く性能問題も発生しやすい, 反映周期が遅い→ユーザー側が扱いにくくなる  バランスよく平衡的に決めること
- 改修コストの大きさ：：論理設計をするときは、：論理設計をするときはシステムの品質はここで決まる. 論理設計には物理設計の知識が必要である。
- SELECT 列1, 列2, COUNT(*) FROM テーブル GROUP BY 列1;とあった場合は、列2はGROUP BY句に含まれていないため、このクエリは多くのデータベースシステムでエラーになる。列2がどのように集約すべきかをSQLエンジンが判断できないから。selectで指定したものとgroup byで指定されたものが一致していないとダメ
- データベースのパフォーマンスを決める主な要因は、ディスク(I/O)の分散(RAID)、SQLにおける結合(正規化)、インデックスと統計情報
- インデックスはパフォーマンス向上に有効な道具だが、正しく使わないと効果が発揮されない
- 統計情報はDBMSにとっては地図情報 最新でなければ最短のアクセスパスを選ぶことができない
- インデックス = (x, α)  xはキー値, αはそれに結びつく情報,実データorポインタ ポインタであることが多い
- インデックスはSQLパフォーマンス改善のために非常にポピュラーな手法  1.アプリケーションのコードに影響を与えない。(アプリケーション透過的)  2.テーブルのデータに影響を与えない(データ透過的) 3.性能改善が大きい
- 存在を意識しなくても良い = 透過性(transparency)
- B-treeインデックス:オール４の成績で総合ナンバーワン
- 最下層のリーフ(葉)と呼ばれるノードだけが、実データに対するポインタを保持している。最上位のノード(ルート)から順にノードを辿ってリーフから実データを見つけにいく
- B-tree = 平衡木である.どんなキー値を使っても、常にリーフまでの距離が一定になるため探索を同じ計算量で行える
- 平衡木:どのリーフもルートからの距離(高さ)が一定の木のことを指す
- B-treeの性能劣化は長期的に見ても緩やか
- B-treeインデックスは、挿入、更新、削除コストも検索と同じくデータ量nに対してO(log n).
- B-treeは等号のみならず不等号やbetweenといった検索範囲の条件に対しても高速化を可能とする
- 構築される時に必ずキー値をソートするため、リーフノードを一つに絞れなくても左右のノードだけに探索範囲を絞ることが可能になる.
- B-treeが効果を持たない検索条件:否定条件(<>,!=)
- ソートはかなりコストの高い演算
- ソートはDBMS内部で専用のメモリ領域が割り当てられておりその内部に一時的にデータを保持して実施される。
- 大量のデータのソートが必要なときは、メモリに載り切らないため溢れる。その場合は一時的にディスクにデータを書き出す。I/Oのコストが非常に大きくなる
- 


# 次やること
- 達人に学ぶDB設計

# 感じたこと
- なし

# 学習時間
- 4.25時間

# 累計学習時間
- 428.5時間
