# 取り組んだ課題一覧
- 達人に学ぶDB設計

# わかったこと
- メタデータ = テーブルやインデックスについてのデータ
- DBMSはメタデータを頼りにSQLのアクセスパスを決定する
- SQL文がDBMSへ発行される。最初はparseと呼ばれるモジュールが適切な構文であるかをチェックする
- parse = 解析する
- optimizerモジュールが実行計画(SQLのアクセスパス)を決める
- DBMSの頭脳, optimizer = 最適化する
- optimizerが実行計画を立てるときに統計情報が必要.
- カタログマネージャというモジュールに統計情報の照会をかける.カタログマネージャから統計情報を受け取り、オプティマイザは最短経路を選択しSQL手続きに変換する
- その時得られた結果が実行計画であり、実行計画をもとに実データへアクセスを行う
- 統計情報の収集:統計情報収集のタイミング、統計情報収集の対象(範囲)
- データが大きく更新されたあとなるべく早く！  更新 = delete,update,insert
- レコード件数の増減、データの値の分布や偏りが変わることもアクセスパスの選定に影響する
- 更新処理によりデータが大きく変わると、古い統計情報と新しい統計情報に齟齬が生じる。
- データの更新量が少ない場合は、統計情報を収集する意味がない。統計情報収集はリソースの消費が大きく且つ処理時間も長い
- 統計情報収集は、基本的にシステムの利用者が少ないタイミングで実施する.
- 統計情報収集の対象(範囲)は、大きく更新があったテーブル(またはインデックス)。CRUD表を作成するのでそれでわかる。
- 特定時点での統計情報の更新をやめることを統計情報を凍結(ロック)する。統計情報の凍結はオプティマイザを信じない悲観的設計。現実で実施するにはかなり大変。
- 原則に反した設計→バッドノウハウ、アンチパターン
- 代表的なバッドノウハウ:非スカラ値、ダブルミーニング、単一参照テーブル、テーブル分割、不適切なキー、ダブルマスタ
- 配列型は採用しない。第１正規形を守る。
- 意味的に分割できる限り、なるべく分割して保持する。意味破壊はNG.分割したものを後で結合するのは簡単、逆は難しい。
- 列は変数ではない、一度意味を決めたら変更不可
- 単一参照テーブル:テーブル全体の意味が七変化する。ポリモーフィズムっぽい感じ。
- テーブルにポリモルフィズムは要らない。
- 水平分割:レコード単位にテーブルを分割すること    垂直分割:列単位にテーブルを分割する
- SQL文のパフォーマンス悪化の原因はストレージに対するI/Oコストの増大.
- DBMSにはパーティション機能があるため、テーブルを分割することなくパーティションキーを軸として(売上テーブルの場合は年度)物理的に格納領域を分離することが可能。これにより、SQLがアクセスするデータ量を1/nに減らせる.(nはパーティション数)
- 集約:テーブル分割の代替え案にに位置付けされる    集約の種類:1.列の絞り込み  2.サマリテーブル
- 小規模なテーブル:データマート(マート)  マートの利点:オリジナルのテーブルを意味破壊することなくパフォーマンスも向上できる  
- 注意点:マートの作りすぎでストレージ圧迫, データの同期をすること→オリジナルの値が更新された場合は、マートの同じ値も更新しなければならない
- マートの更新タイミングが短いとデータの精度が高いが、更新処理の負荷がかかるため性能問題が帰って悪化する可能性もある
- マートの更新頻度:バッチ更新(一括処理)で1日に1回から数回
- サマリテーブル:集約の手段の一つ。列の絞り込みと違う点は、集約関数によってレコードを集約した状態で保持する
- - 主キー、外部キーなどデータベース機能で設定されるもの
- テーブルの結合条件で使用される列(結合キー)
- 使っちゃダメなデータ型はVARCHAR(可変長文字列):キーが満たすべき条件である不変性(Stability)を備えていない  2.固定長文字列(CHAR)との混同
- コロコロ変わる列をキーにすると、データ更新処理が多く発生するためシステムの安定的な運用とパフォーマンスの両面でマイナスになる
- 固定長文字列と可変長文字列は同じ文字列を保持しようとしても物理的には同じ値にならない。固定長文字列が空白による穴埋め(パディング)をするから
- キーには固定長文字列のコード列が望ましい
- 一方が固定長文字列で宣言されてもう一方が可変長文字列で宣言されていると列同士の比較でアンマッチが起きる。文字列型 : 数値型でも同じことが起きる
- ダブルマスタはシステムの統廃合で起きる
- グレーノウハウ:代理キー,列待ちテーブル,アドホックな集計キー,多段ビュー
- 主キーが決められない、主キーとして不十分なケース: パターン１　そもそも入力データに主キーにできるような一意キーが存在しない パターン２　一意キーであるが、サイクリックに使いまわされる   パターン３　一意キーであるが、途中で指す対象が変化する
- 代理キー(surrogate key):入力データに最初から存在しているキーの代理として新たに追加するキー/人工的なキーをシステム側に付与することで、自然キーを主キーで選んだ時に発生する不具合を解決できる。
- タイムスタンプ:データの形式が単縦になるためSQLの条件も簡単になる。  必ず一つのスナップショットに含まれる列をフルセットで持っていなければならない。更新頻度が頻繁だと、レコード数が膨大になる
- インターバル:テーブルの有効な期間を表す方式  メリット:開始年度と終了年度の列を新規作成してデータの有効年度を示している.データの有効期限が切れたら既存レコードに書き込むだけで完結する  デメリット:SQLで必ず範囲指定しないといけなくなる。
- オートナンバリング:一位な数値を自動的に割り振る方法
- 二つの要件を守る:1.重複値が存在しないこと  2.歯抜けが生じないこと
- オートナンバリングの実現方法(DB機能): シーケンスオブジェクト,ID列
- シーケンスとID列ではシーケンスの方がより柔軟で拡張性に富む
- 採番テーブル:１行１列の整数型のデータを持つ採番テーブルを用意し他のテーブルにデータ登録をするたびにインクリメントしていく
- デメリット:プログラムの開発とテストが必要.採番テーブルと連番を使用するテーブルが密接に関連していて欠けたらシステムが動かない.ER図からはその依存関係が分からない.
- →排他制御をしないと機能的なバグが生まれる ex)2人同時に同じ採番テーブルにアクセスして同じ番号を引き当てて更新処理をした時に一意性制約違反となる.番号が飛び石になったりする可能性がある.
- 解決方法としては、1人が採番テーブルへアクセスしたときにロックして他の人間には参照や更新できないようにする.シーケンスオブジェクトでは、ロックメカニズムが実装されているためこれらを利用できる
- 列持ちテーブル = 繰り返し項目テーブル
- 列持ちテーブルのメリット:シンプルな設計, 入出力フォーマットと合わせやすい デメリット:列の増減が激しい,  無用のnullを使わなくてはならない
- アドホックな集計キーとは?:集計がしやすいように集計キーを追加すること.集計は可能になるがテーブルが巨大なほど、どんどんサイズが大きくなりパフォーマンスに影響を及ぼす
- 解決策:キーを別テーブルに分離する. ビューを使う. group by句の中でアドホックキーを作る
- caseはselect,where,group by,having,order byに書くことができる
- ビューはselect文を保存して一種のテーブルとして扱うことができるため、正規化されたテーブルの結合など複雑な操作を要するselect文をビュー化することで上位レイヤーのアプリケーションのプログラミングを簡潔に行える
- ビューはテーブルと違い、データを保持しない.ビュー定義のselect文を実行して、オリジナルのテーブルにアクセスしている(オリジナルテーブル=基底テーブル) ２段階のアクセスがされているとイメージすること
- ビューのselect文と基底テーブルのselect文をマージして、効率のいい形で実行しようとする。高コストな処理である。
- ビューの背後にあるテーブルの存在を常に意識せよ.過度に複雑な作りはシステムをダメにする.
- データクレンジング:それまで業務で利用されていたデータをデータベースに登録できる状態にする作業
- 一意キーの存在しないデータはバッドノウハウ「不適切なキー」をも生み出す
- 名寄せ:似ている名前を統合する.標準化の一種
- 名寄せが発生する根本原因:フリーハンドの入力を許しているから
- 名寄せをサボるとダブルマスタが誕生する
- 名寄せの方法は？  別の情報と組み合わせて確度を高める:名前が漢字が違う。だけど、住所が一緒で年齢も同じなら同一人物である,  情報の頻出具合:珍しい情報であればフォーマットが違えど同一である
- 一時テーブルは、性能的に不利な条件での戦いを強いられる

# 次やること
- 達人に学ぶDB設計

# 感じたこと
- 8章まで終わったので明日9章を終わらせてSQLとDB設計の記事作成に取り掛かります。
- 余裕があったら、DB設計の課題にもチャレンジ

# 学習時間
- 7時間

# 累計学習時間
- 435.5時間
