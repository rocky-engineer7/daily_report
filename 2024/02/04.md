# 取り組んだ課題一覧
- 達人に学ぶDB設計
- すっきり分かるSQLブログ記事作成
- 達人に学ぶDB設計ブログ記事作成

# わかったこと
- RDBは木構造のデータ形式が苦手
- ノード:木の結節点, ルートノード:木が始まるトップのノード,ルートノードは一つしかない, リーフノード:終着点のノード,自分よりも下位ノードを持たない, 内部ノード:ルートでもリーフでもない中間のノード
- 経路(パス):あるノードから別のノードへたどる道筋
- 隣接リストモデル:ノードのレコードに親ノードの情報(ポインタ)を持たせようとするもの
- 更新や検索のクエリが複雑になりパフォーマンスも悪くなる
- 入れ子集合モデルではノードを円とみなす, ノード間の階層関係を円の包含関係で表す
- 円の左端と右端で座標を表現している。右端-左端で円の直径が決まる
- ルートとリーフのノードを探す, あるノードの深さ（階層の位置）を求める場合は、包含関係に翻訳すれば良い
- 一つの値を追加するのに、更新対象と無関係の円まで更新しなければならない。 入れ子モデルの弱点でもある。
- 部分木＝下位ノードを含めたノード,  部分木を削除すると下位ノードも削除される(連座)
- 入れ子区間モデルは実数を扱う, 入れ子集合モデルの拡張版 リソース無限なら最強だけど、有効桁数の限界が絶対来るから未来のモデル
- 経路列挙モデル=経路実体化モデル: ルートをディレクトリとみなし、各ノードまでの経路を記述する
- 経路列挙モデルをテーブルで表すのは２パターン:主キーを使う, 番号を使う
- 経路列が各ノードまでの絶対パスを保持する
- UNIX/linuxのファイルシステムの構造と同じ
- メリット:検索のパフォーマンスが良いこと,ノード自身に親子関係が含まれているので経路探索のSQL文が圧倒的に楽になる,PostgreSQLやOracleと親和性がある
- デメリット:経路を主キーで使うと経路の文字列が非常に長大になる.DBMSの可変長文字列の上限値を超えると現実的な利用が難しい, 経路を主キーにすると同じ階層内のノード同士の順序が把握できない, パス番号を使うとノードの追加と削除と更新が複雑,コード依存の実装になる
- 更新が少なく、大量データの高速な検索が必要なケースに向いている(DWH/BI)
- 自分のパスの後ろに追加のパスを持つような他のノードが存在しない→NOT EXISTSを使えば良い
- '_%' は「一文字以上の任意の文字列」を意味する文字列パターン,likeは前方一致検索ではインデックスを使用する.該当列のユニークインデックスが利用できてパフォーマンスに良い影響を与える
- 経路列挙モデルで親ノードを追加更新する時はかなり複雑
- 経路列挙モデルで部分木を削除するとそれにぶら下がるノードも削除される
- likeの中間一致はインデックスを利用できないため、そのテーブルをフルスキャンすることになる→パフォーマンス悪化


# 次やること
- すっきり分かるSQL記事作成

# 感じたこと
- 久々のブログ記事本当に疲れました。構成どうするかとか語彙力のなさでかなり時間使いました。

# 学習時間
- 7.5時間

# 累計学習時間
- 443時間
