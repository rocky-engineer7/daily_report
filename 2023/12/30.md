# 取り組んだ課題一覧
- すっきり分かるSQL

# わかったこと
-　データ操作:DML テーブル作成・削除:DDL トランザクション:TCL DMLやDDLの許可・禁止の設定DCL
- create table文:テーブルの新規作成 テーブル作成時に、デフォルト値を設定可 drop table:テーブル削除 alter table:テーブル定義の変更
- 参照整合性:外部キーで別のテーブルを参照しているのにその行が存在しないこと
- テーブル作成時に各列の制約を設定する。予期せぬ値を格納しないように安全装置を設ける。
- not null:NULLの格納を防ぐことができる unique:重複した値の格納を防ぐ check:格納する値が妥当かどうかをチェックする
- primary key:主キーとして取扱いたい列に記述する 複合主キーの場合は primary key (列名, 列名)
- foreign key:外部キー制約 references 参照先テーブル名(参照先列名)
- データ更新や削除で、外部キーによる参照整合性が崩れることがないように外部キー制約を設定する
- index((索引情報)：　インデックスは指定した列に大して作られる。インデックスが存在する列に対して検索が行われると、DBMSはインデックスの使用を試みるため高速になる場合が多い。インデックスには必ず名前をつける。
- インデックスの作成:create index インデックス名 on テーブル名(列名)
- インデックスの削除:drop index インデックス名
- where句による絞り込み、order byによる並び替え、joinによる結合の条件.この３パターンでインデックスのメリットを享受する
- インデックスのデメリット：ディスク容量を消費する。テーブルのデータが変更されると、インデックスも書き換える必要がある。insert,delete,updateのオーバーヘッドが増える
- DBMSもどの順番でどのような方法でアクセスするかを分析し、planと呼ばれる作戦を立ててから実行に移る
- explain文で指定したSQL文の実行するプランを調べることができる
- view:結果表をテーブルのように扱える.viewの実体は単なる名前を付けたSELECT文　一見シンプルだけど、DBMS側ではviewを展開してSQL文に変換して実行するため長く冗長なSQL文になることもある
- 採番:適切な番号を取得すること.
- 連番が自動的に振られる特殊な列を定義する(GENERATED ALWAYS AS IDENTITY PRIMARY KEY) DBの製品ごとで書き方が異なる
- シーケンス:裁判した最新の値を常に記録している。シーケンスに指示を出すことで現在の値や次の値を取り出すことが可能
- backup:データ消失に備えて、データベースの全内容をファイルに出力する
- オフラインバックアップ：データベースを停止してからバックアップを行う その間読み書き不可
- オンラインバックアップ:DBMSを稼働させながら行うバックアップ　制約あり
- ACIDは「原子性（Atomicity）」、「一貫性（Consistency）」、「隔離性（Isolation）」、「耐久性（Durability）」
- データベースは低頻度、ログファイルは高頻度でバックアップを取得する
- ログファイルとは、REDOログや、アーカイブログ、トランザクションログなどと呼ばれる。それまでデータベースを更新した全てのSQL文のこと
- ロールフォアード(まだ実行されていない処理を実行する):障害復旧時に行われる処理のため滅多に発生しない
- 近年ではUUIDを１２８ビットのランダムな数値をアルゴリズムに従って生成。　例)123e4567-e89b-12d3-a456-426614174000 世界中で一意であることが保証される128ビットの数値
- 

# 次やること
- すっきり分かるSQL

# 感じたこと
-　なし

# 学習時間
- 5時間

# 累計学習時間
- 374.25
